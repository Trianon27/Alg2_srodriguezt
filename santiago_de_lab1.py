# -*- coding: utf-8 -*-
"""Santiago-de lab1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lTWLeIlvGjf6Kip8q6LxnnXG09j4mpXq

<div align="center">
<img style="display: block; margin: auto;" alt="photo" src="https://cdn.quantconnect.com/web/i/icon.png">

Quantconnect

Introduction to Financial Python
</div>

# 01 Data Types and Data Structures

# Introduction

This tutorial provides a basic introduction to the Python programming language. If you are new to Python, you should run the code snippets while reading this tutorial. If you are an advanced Python user, please feel free to skip this chapter.

# Basic Variable Types
The basic types of variables in Python are: strings, integers, floating point numbers and booleans.

Strings in python are identified as a contiguous set of characters represented in either single quotes (' ') or double quotes (" ").
"""

# This code prints the concatenation of two strings
my_string1 = 'Welcome to'
my_string2 = "QuantConnect"
print(my_string1 + ' ' + my_string2)

presentation = "My name is"
Name = 'Santiago Rodríguez'
print(presentation + ' ' + Name)

"""An integer is a round number with no values after the decimal point."""

# This function print the type of the input, in this case is a int.
my_int = 10
s1 = "Char"
print(my_int)
print(type(my_int))
print(s1)
print(type(s1))

"""The built-in function int() can convert a string into an integer."""

# This function converts a string into an integer, in this case, we convert "100" to 100
my_string = "100"
print(type(my_string))
my_int = int(my_string)
print(type(my_int))

"""A floating point number, or a float, is a real number in mathematics. In Python we need to include a value after a decimal point to define it as a float"""

""" To include a decimal value. We can convert the integers to float numbers, that's allow me to use decimals
    in the code"""

my_string = "100"
my_float = float(my_string)
print(type(my_float))

"""As you can see above, if we don't include a decimal value, the variable would be defined as an integer. The built-in function float() can convert a string or an integer into a float."""

# This function prints the value of "my_bool" and then prints the type of the data that it is. 
my_bool = False
print(my_bool)
print(type(my_bool))

"""A boolean, or bool, is a binary variable. Its value can only be True or False. It is useful when we do some logic operations, which would be covered in our next chapter."""

# This function prints the kind of arithmetic operations as addition, subtraction, multiplication, etc.
print("Addition ", 1+1)
print("Subtraction ", 5-2)
print("Multiplication ", 2*3)
print("Division ", 10/2)
print('exponent', 2**3)

"""# Basic Math Operations

The basic math operators in python are demonstrated below:
"""

# This function prints two divisions
print(1/3)
print(1.0/3)

"""# Data Collections

## List
A list is an ordered collection of values. A list is mutable, which means you can change a list's value without changing the list itself. Creating a list is simply putting different comma-separated values between square brackets.
"""

# This function prints a list that contains any kind of data
my_list = ['Quant', 'Connect', 1,2,3]
print(my_list)

"""The values in a list are called "elements". We can access list elements by indexing. Python index starts from 0. So if you have a list of length n, the index of the first element will be 0, and that of the last element will be n − 1. By the way, the length of a list can be obtained by the built-in function len()."""

""" In this function we can see three types of operation
    1) We ca know hoy long is the list
    2) We can take, knowing the position, an specified fact.
    3) We can take the real length of the string if we substracct the len of the list less 1, becasuse
    we always are going to take the positon 0 as a valid position.

"""
my_list = ['Quant', 'Connect', 1,2,3]
print(len(my_list))
print(my_list[0])
print(my_list[len(my_list) -1])

"""You can also change the elements in the list by accessing an index and assigning a new value."""

# This function change the element of the list, in this case we change "1" to 'go'
my_list = ['Quant','Connect',1,2,3]
my_list[2] = 'go'
print(my_list)

"""A list can also be sliced with a colon:"""

# This function slice the list, in this case the function takes the first element (the second in the list) and 
# the second (third in the list), it not takes the last itme (fourth of the list)
my_list = ['Quant','Connect',1,2,3]
print(my_list[1:3])

"""The slice starts from the first element indicated, but excludes the last element indicated. Here we select all elements starting from index 1, which refers to the second element:"""

# This function takes from the first element (second in the list) to the last element, thats' is because we didn't put the limit element
print(my_list[1:])

"""And all elements up to but excluding index 3:"""

#  As same as the last function, in this case, the limit is found in the last element. The difference is that the limit number isn´t taken it
print(my_list[:3])
print(my_list[:4])

"""If you wish to add or remove an element from a list, you can use the append() and remove() methods for lists as follows:"""

# This function adds an element to the list. The element is added at the end of the list.
my_list = ['Hello', 'Quant']
my_list.append('Hello')
print(my_list)

# As same as we can append, we can also remove from the list
my_list.remove('Hello')
print(my_list)

"""When there are repeated instances of "Hello", the first one is removed.

## Tuple
A tuple is a data structure type similar to a list. The difference is that a tuple is immutable, which means you can't change the elements in it once it's defined. We create a tuple by putting comma-separated values between parentheses.
"""

# This function creates three elements in a tuple
my_tuple = ('Welcome','to','QuantConnect')

"""Just like a list, a tuple can be sliced by using index."""

# This fucntion slices the tuple in a renge of determined numbers
my_tuple = ('Welcome','to','QuantConnect')
print(my_tuple[1:])

"""## Set
A set is an **unordered**  collection with **no duplicate** elements. The built-in function **set()** can be used to create sets.
"""

# This function creates a list, and then the whole list is entered in a set. The set removes the duplicate element and then it prints it.
stock_list = ['AAPL','GOOG','IBM','AAPL','IBM','FB','F','GOOG']
stock_set = set(stock_list)
print(stock_set)

"""Set is an easy way to remove duplicate elements from a list.

##Dictionary
A dictionary is one of the most important data structures in Python. Unlike sequences which are indexed by integers, dictionaries are indexed by keys which can be either strings or floats.

A dictionary is an **unordered** collection of key : value pairs, with the requirement that the keys are unique. We create a dictionary by placing a comma-separated list of key : value pairs within the braces.
"""

#The function creates a dictionary in which one you can append keys with it respective values
my_dic = {'AAPL':'AAPLE', 'FB':'FaceBook', 'GOOG':'Alphabet'}

# When we are going to print a item, we take the key but it prints the value 
print(my_dic['GOOG'])

"""After defining a dictionary, we can access any value by indicating its key in brackets."""

# This function change the value of the key GOOG, it takes the alphabet and it changed to Alphabet Company
my_dic = {'AAPL':'AAPLE', 'FB':'FaceBook', 'GOOG':'Alphabet'}
my_dic['GOOG'] = 'Alphabet Company'
print(my_dic['GOOG'])

"""We can also change the value associated with a specified key:"""

#This fucntion prints all the keys of our dictionary 
my_dic = {'AAPL':'AAPLE', 'FB':'FaceBook', 'GOOG':'Alphabet'}
print(my_dic.keys())

"""The built-in method of the dictionary object dict.keys() returns a list of all the keys used in the dictionary.

# Common String Operations
A string is an immutable sequence of characters. It can be sliced by index just like a tuple:
"""

# This function slice an string because is similar to the list.
my_str = 'Welcome to QuantConnect'
print(my_str[8:])

"""There are many methods associated with strings. We can use string.count() to count the occurrences of a character in a string, use string.find() to return the index of a specific character, and use string.replace() to replace characters"""

# This function complet three particular task: Counts the elements of the strings (e in this case)
# find the first position of an element (in this case the first e is in the second position) and replace all the e's to a's
print('Counting the number of e appears in this sentence'.count('e'))
print('The first time e appears in this sentence'.find('e'))
print('all the a in this sentence now becomes e'.replace('a','e'))
print('Hi, my name is GUSTAVO'.replace('a','i'))

"""The most commonly used method for strings is string.split(). This method will split the string by the indicated character and return a list:"""

# This function takes the time and split it, then it takes the specific values and prints them, and finally, print the hour
Time = '2016-04-01 09:43:00'
splited_list = Time.split(' ')
date = splited_list[0]
time = splited_list[1]
print(date, time)
hour = time.split(':')[0]
print(hour)

"""We can replace parts of a string by our variable. This is called string formatting."""

# This function let to the user to put his data using the function format
my_time = 'Hour: {}, Minute:{}'.format('09','43')
print(my_time)

"""Another way to format a string is to use the % symbol."""

# As the last function this one let the user to put his data using in this case "%" after the string
print('the pi number is %f'%3.14)
print('%s to %s'%('Welcome','Quantconnect'))

"""# Summary

Weave seen the basic data types and data structures in Python. It's important to keep practicing to become familiar with these data structures. In the next tutorial, we will cover for and while loops and logical operations in Python.

<div align="center">
<img style="display: block; margin: auto;" alt="photo" src="https://cdn.quantconnect.com/web/i/icon.png">

Quantconnect

Introduction to Financial Python
</div>

# 02 Logical Operations and Loops

# Introduction
We discussed the basic data types and data structures in Python in the last tutorial. This chapter covers logical operations and loops in Python, which are very common in programming.

# Logical Operations
Like most programming languages, Python has comparison operators:
"""

# This function apply the logical operations
print(1 == 0)  #Equal
print(1 == 1)  
print(1 != 0)  #Diferent 
print(5 >= 5)  # Greater than 
print(5 >= 6)

"""Each statement above has a boolean value, which must be either True or False, but not both.

We can combine simple statements P and Q to form complex statements using logical operators:

- The statement "P and Q" is true if both P and Q are true, otherwise it is false.
- The statement "P or Q" is false if both P and Q are false, otherwise it is true.
- The statement "not P" is true if P is false, and vice versa.
"""

# This function apply logical operations but instead of one it applies two, using and conectors
print(2 > 1 and 3 > 2)
print(2 > 1 and 3 < 2) 
print(2 > 1 or 3 < 2)
print(2 < 1 and 3 < 2)

"""When dealing with a very complex logical statement that involves in several statements, we can use brackets to separate and combine them."""

# The function apply logical operators but applies more of one, in this case applied the connector "or" and "and not". Also we can see the function of the brackets separating the different operations.
print((3 > 2 or 1 < 3) and (1!=3 and 4>3) and not ( 3 < 2 or 1 < 3 and (1!=3 and 4>3)))
print(3 > 2 or 1 < 3 and (1!=3 and 4>3) and not ( 3 < 2 or 1 < 3 and (1!=3 and 4>3)))

"""Comparing the above two statements, we can see that it's wise to use brackets when we make a complex logical statement.

# If Statement
An if statement executes a segment of code only if its condition is true. A standard if statement consists of 3 segments: if, elif and else.

```python
if statement1:
    # if the statement1 is true, execute the code here.
    # code.....
    # code.....
elif statement2:
    # if the statement 1 is false, skip the codes above to this part.
    # code......
    # code......
else:
    # if none of the above statements is True, skip to this part
    # code......
```

An if statement doesn't necessarily has elif and else part. If it's not specified, the indented block of code will be executed when the condition is true, otherwise the whole if statement will be skipped.
"""

#The function use the if condition to accept with a logical operation the condition that it has in this case, i == 0.
i = 0
if i == 0:
    print('i==0 is True')

"""As we mentioned above, we can write some complex statements here:"""

# This function has an elif condition, that's implies that if the first condition cant be accept the algorithm will pass to the next condition until complete one of these conditions
p = 1 > 0
q = 2 > 3
if p and q:
    print('p and q is true')
elif p and not q:
    print('q is false')
elif q and not p:
    print('p is false')
else:
    print('None of p and q is true')

"""# Loop Structure
Loops are an essential part of programming. The "for" and "while" loops run a block of code repeatedly.

## While Loop
A "while" loop will run repeatedly until a certain condition has been met.
"""

# This function use a while loop. The program will run until the condition is accepted. In this case  "I" had to be added by 1 until complete 5
i = 0
while i < 5:
    print(i)
    i += 1

"""When making a while loop, we need to ensure that something changes from iteration to iteration so that the while loop will terminate, otherwise, it will run forever. Here we used i += 1 (short for i = i + 1) to make i larger after each iteration. This is the most commonly used method to control a while loop.

## For Loop
A "for" loop will iterate over a sequence of value and terminate when the sequence has ended.
"""

"""
The for loop go through the list until complete the whole list
"""
for i in [1,2,3,4,5]:
    print(i)

"""We can also add if statements in a for loop. Here is a real example from our pairs trading algorithm:"""

# This function use a if condtion and foor loop, firstly the program creates the list, then it pass for the for loop. Once th 
# process is in the loop, the program will read the condition and will or will not, accept the condition, in this case the if's operation
# checks if the elements of the stocks list are in the selected list 
stocks = ['AAPL','GOOG','IBM','FB','F','V', 'G', 'GE']
selected = ['AAPL','IBM']
new_list = []
for i in stocks:
    if i not in selected:
        new_list.append(i)
print(stocks)

"""Here we iterated all the elements in the list 'stocks'. Later in this chapter, we will introduce a smarter way to do this, which is just a one-line code.

## Break and continue
These are two commonly used commands in a for loop. If "break" is triggered while a loop is executing, the loop will terminate immediately:
"""

# This function iterate every item of the list "stocks" until one of the items accomplish the condition, if this occurred the "for" is broken
stocks = ['AAPL','GOOG','IBM','FB','F','V', 'G', 'GE']
for i in stocks:
    print(i)
    if i == 'FB':
        break

"""The "continue" command tells the loop to end this iteration and skip to the next iteration:"""

# This function works as same as the last algorithm. The difference is that "continue" lets us pass the action of the code condition.
stocks = ['AAPL','GOOG','IBM','FB','F','V', 'G', 'GE']
for i in stocks:
    if i == 'FB':
        continue
    print(i)

"""# List Comprehension
List comprehension is a Pythonic way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence. For example, if we want to create a list of squares using for loop:
"""

#This function uses a for a loop. 
#The program defines an empty list. The program begins when the loop runs through the list taking every item of it. 
#Inside the loop, the item is power in 2 and its append into the empty list
squares = []
for i in [1,2,3,4,5]:
    squares.append(i**2)
print(squares)

"""Using list comprehension:"""

# This function creates a comprehension list, as you can see. The items were created inside the list using a for loop.
list = [1,2,3,4,5]
squares = [x**2 for x in list]
print(squares)

"""Recall the example above where we used a for loop to select stocks. Here we use list comprehension:"""

#The function creates a list using the comprehension lists. It is the same example as some examples above.
stocks = ['AAPL','GOOG','IBM','FB','F','V', 'G', 'GE']
selected = ['AAPL','IBM']
new_list = [x for x in stocks if x in selected]
print(new_list)

"""A list comprehension consists of square brackets containing an expression followed by a "for" clause, and possibly "for" or "if" clauses. For example:"""

"""
The function creates tuples. In the first loop, we can note that we have a collection of tuples taking
two coordinates: 'X' and 'y'. The condition of this loop is that the program has not to repeat the same coordinate in 'x's and 'y'

The other 'print' takes one element of two lists, using, for this case two loops. Then the program faces both elements

"""
print([(x, y) for x in [1,2,3] for y in [3,1,4] if x != y])
print([str(x)+' vs '+str(y) for x in ['AAPL','GOOG','IBM','FB'] for y in ['F','V','G','GE'] if x!=y])

"""List comprehension is an elegant way to organize one or more for loops when creating a list.

# Summary
This chapter has introduced logical operations, loops, and list comprehension. In the next chapter, we will introduce functions and object-oriented programming, which will enable us to make our codes clean and versatile.

<div align="center">
<img style="display: block; margin: auto;" alt="photo" src="https://cdn.quantconnect.com/web/i/icon.png">

Quantconnect

Introduction to Financial Python
</div>

# 03 Functions and Objective-Oriented Programming

# Introduction

In the last tutorial we introduced logical operations, loops and list comprehension. We will introduce functions and object-oriented programming in this chapter, which will enable us to build complex algorithms in more flexible ways.

# Functions
A function is a reusable block of code. We can use a function to output a value, or do anything else we want. We can easily define our own function by using the keyword "def".
"""

# This program define a function that multiplies two numbers and then it returns me the product
def product(x,y):
    return x*y
print(product(2,3))
print(product(5,10))

"""The keyword "def" is followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The product() function above has "x" and "y" as its parameters. A function doesn't necessarily have parameters:"""

# The program defines a function without parameters. The function print a string
def say_hi():
    print('Welcome to QuantConnect')
say_hi()

"""# Built-in Function
**range()** is a function that creates a list containing an arithmetic sequence. It's often used in for loops. The arguments must be integers. If the "step" argument is omitted, it defaults to 1.
"""

# The program uses the range() function, that is ranges from a min number to a max number.
print(range(10))
print(range(1,11))
print(range(1,11,2))

"""**len()** is another function used together with range() to create a for loop. This function returns the length of an object. The argument must be a sequence or a collection."""

# This program uses the len() function. The function counts the length of the list "tickers", print the length, and then the program, using a loop, prints every element
tickers = ['AAPL','GOOG','IBM','FB','F','V', 'G', 'GE']
print('The length of tickers is {}'.format(len(tickers)))
for i in range(len(tickers)):
    print(tickers[i])

"""Note: If you want to print only the tickers without those numbers, then simply write "for ticker in tickers: print ticker"

**map(**) is a function that applies a specific function to every item of a sequence or collection, and returns a list of the results.

Because list at the moment is [1,2,3,4,5] and overwriting list() from builtins we del list
"""

# As you can see the "del" already deletes the object
print(list)
del list
list

#The program associates the len with the element of the "ticker" list using a map
tickers = ['AAPL','GOOG','IBM','FB','F','V', 'G', 'GE']
list(map(len,tickers))

#The program associates the len with the element of the "ticker" list using a map
tickers = ['AAPL','GOOG','IBM','FB','F','V', 'G', 'GE']
print(list(map(len,tickers)))

"""The **lambda operator** is a way to create small anonymous functions. These functions are just needed where they have been created. For example:"""

# The program uses lambda as a little function inside my map function where the program can iterate the elements or items
# that you give it
first = list(map(lambda x: x**2, range(10)))
second = list(map(lambda y: y/2, range(1,10)))
third = list (map(lambda z: z/2, [1,2,3,4,4]))
print(first, second, third)

"""map() can be applied to more than one list. The lists have to have the same length."""

# In this case the program gave us the map iteration using two lists. The lambda adds the elements of one list with the elements of the other one
list(map(lambda x, y: x+y, [1,2,3,4,5],[5,4,3,2,1]))

"""**sorted()** takes a list or set and returns a new sorted list"""

# The program order the list 
sorted([5,2,3,4,1])

"""We can add a "key" parameter to specify a function to be called on each list element prior to making comparisons. For example:"""

# The program order the list where you can give a parameter to the function, for this case the program uses the second element of the tuple to sort the list
price_list = [('AAPL',144.09),('GOOG',911.71),('MSFT',69),('FB',150),('WMT',75.32)]
print(sorted(price_list, key = lambda x: x[1]))
sorted(price_list, key = lambda x: x[0])

"""By default the values are sorted by ascending order. We can change it to descending by adding an optional parameter "reverse'."""

# The fucntion sorts the list in a descending way using the parameter reverse. The function takes the same creiterium to order 
# the list that is the second element of the tuple 
price_list = [('AAPL',144.09),('GOOG',911.71),('MSFT',69),('FB',150),('WMT',75.32)]
sorted(price_list, key = lambda x: x[1],reverse = True)

"""Lists also have a function list.sort(). This function takes the same "key" and "reverse" arguments as sorted(), but it doesn't return a new list."""

# The sort function only use  the key parameter and does the same as if we gave it the list inside the function
price_list = [('AAPL',144.09),('GOOG',911.71),('MSFT',69),('FB',150),('WMT',75.32)]
price_list.sort(key = lambda x: x[1])
print(price_list)

"""# Object-Oriented Programming
Python is an object-oriented programming language. It's important to understand the concept of "objects" because almost every kind of data from QuantConnect API is an object.

## Class
A class is a type of data, just like a string, float, or list. When we create an object of that data type, we call it an instance of a class.

In Python, everything is an object - everything is an instance of some class. The data stored inside an object are called attributes, and the functions which are associated with the object are called methods.

For example, as mentioned above, a list is an object of the "list" class, and it has a method list.sort().

We can create our own objects by defining a class. We would do this when it's helpful to group certain functions together. For example, we define a class named "Stock" here:
"""

# The program create a class with a constructor and it methods
class stock:
    #Constructor 
    def __init__(self, ticker, open, close, volume):
        self.ticker = ticker
        self.open = open
        self.close = close
        self.volume = volume
        self.rate_return = float(close)/open - 1

    # This is one of the method created, this method change the value of ope, close and rate_return
    def update(self, open, close):
        self.open = open
        self.close = close
        self.rate_return = float(self.close)/self.open - 1

    # This function return the value of rate_return 
    def print_return(self):
        print(self.rate_return)



if __name__ == "__main__":
    pedro = stock('AAPL', 143.69, 144.09, 20109375)
    pedro.update(1.2,3.2)
    pedro.print_return()

"""The "Stock" class has attributes "ticker", "open", "close", "volume" and "rate_return". Inside the class body, the first method is called __init__, which is a special method. When we create a new instance of the class, the __init__ method is immediately executed with all the parameters that we pass to the "Stock" object. The purpose of this method is to set up a new "Stock" object using data we have provided.

Here we create two Stock objects named "apple" and "google".
"""

# The program creates two objects of the class stock 
apple = stock('AAPL', 143.69, 144.09, 20109375)
google = stock('GOOG', 898.7, 911.7, 1561616)

"""Stock objects also have two other methods: update() and print_return(). We can access the attribues of a Stock object and call its methods:"""

# The function applies the methods that were described above 
apple.ticker
google.print_return()
google.update(912.8,913.4)
google.print_return()

"""By calling the update() function, we updated the open and close prices of a stock. Please note that when we use the attributes or call the methods **inside a class**, we need to specify them as self.attribute or self.method(), otherwise Python will deem them as global variables and thus raise an error.

We can add an attribute to an object anywhere:
"""

# The function adds an attribute to the object. The function  gives the name of the apple  CEO
apple.ceo = 'Tim Cook'
print(apple.ceo) 
pedro.name = 'El pepe'
pedro.name

"""We can check what names (i.e. attributes and methods) are defined on an object using the dir() function:"""

# We can check the attributes of mine object 
dir(apple)

"""## Inheritance
Inheritance is a way of arranging classes in a hierarchy from the most general to the most specific. A "child" class is a more specific type of a "parent" class because a child class will inherit all the attribues and methods of its parent. For example, we define a class named "Child" which inherits "Stock":
"""

# The program creates a class that inherits the methods and attributes of his parent class called stock
class child(stock):
    def __init__(self,name):
        self.name = name

# As you can see, the program creates an object that can use the same methods as its parent class
aa = child('aa')
print(aa.name)
aa.update(100,102)
print(aa.open)
print(aa.close)
print(aa.print_return())

"""As seen above, the new class Child has inherited the methods from Stock.

#Summary

In this chapter we have introduced functions and classes. When we write a QuantConnect algorithm, we would define our algorithm as a class (QCAlgorithm). This means our algorithm inherited the QC API methods from QCAlgorithm class.

In the next chapter, we will introduce NumPy and Pandas, which enable us to conduct scientific calculations in Python.

<div align="center">
<img style="display: block; margin: auto;" alt="photo" src="https://cdn.quantconnect.com/web/i/icon.png">

Quantconnect

Introduction to Financial Python
</div>

# 04 NumPy and Basic Pandas

# Introduction

Now that we have introduced the fundamentals of Python, it's time to learn about NumPy and Pandas.

# NumPy
NumPy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays. It also has strong integration with Pandas, which is another powerful tool for manipulating financial data.

Python packages like NumPy and Pandas contain classes and methods which we can use by importing the package:
"""

# The program imports NumPy's library 
import numpy as np

"""## Basic NumPy Arrays
A NumPy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. Here we make an array by passing a list of Apple stock prices:
"""

# To convert a list into NumPy list you have to pass the list as a parameter of my "np.array" function
price_list = [143.73, 145.83, 143.68, 144.02, 143.5, 142.62]
price_array = np.array(price_list)
print(price_array, type(price_array))

lista = [1,2,3,4,5,6]
lista_2 = [2,3,4,5,5,6]
print(np.array([lista, lista_2]))

"""Notice that the type of array is "ndarray" which is a multi-dimensional array. If we pass np.array() a list of lists, it will create a 2-dimensional array."""

# The program creates a dimensional list with two lists using the np.array
Ar = np.array([[1,3],[2,4]])
print(Ar, type(Ar))

"""We get the dimensions of an ndarray using the .shape attribute:"""

# The shape attribute gave us the dimensions of our array
print(Ar.shape)

"""If we create an 2-dimensional array (i.e. matrix), each row can be accessed by index:"""

#You can check the specific row using the name of your array and the index
print(Ar[0])
print(Ar[1])

"""If we want to access the matrix by column instead:"""

# The program presents us with a way to look at the columns. These can be seen using the name of the array and index with the different than before but the number you use a ":,"
print('the first column: ', Ar[:,0])
print('the second column: ', Ar[:,1])

"""## Array Functions
Some functions built in NumPy that allow us to perform calculations on arrays. For example, we can apply the natural logarithm to each element of an array:
"""

# This function calculates the logarithm to all items of the array
print(np.log(price_array))

"""Other functions return a single value:"""

print(np.mean(price_array)) # Calculates mean of my array
print(np.std(price_array)) # Takes the standart deviation of my array
print(np.sum(price_array)) # Calculates the sum of my array items
print(np.max(price_array)) # Takes the max value of my items

"""The functions above return the mean, standard deviation, total and maximum value of an array.

# Pandas
Pandas is one of the most powerful tools for dealing with financial data. 

First we need to import Pandas:
"""

# The program imports pandas
import pandas as pd

"""## Series
Series is a one-dimensional labeled array capable of holding any data type (integers, strings, float, Python object, etc.)

We create a Series by calling pd.Series(data), where data can be a dictionary, an array or just a scalar value.
"""

# The program converts the list into a pandas series, and then its print type of the object
price = [143.73, 145.83, 143.68, 144.02, 143.5, 142.62]
s = pd.Series(price)
s

"""We can customize the indices of a new Series:"""

# The function can be customized using a different index
s = pd.Series(price,index = ['a','b','c','d','e','f'])
print(s , "\n")
s = pd.Series(price,index = ['First','Second','Third','Fourth','Fifth','Sixth'])
s

"""Or we can change the indices of an existing Series:"""

#The function changes the index of the series 
s.index = [6,5,4,3,2,1]
s

"""Series is like a list since it can be sliced by index:"""

# As same as a list the series can be sliced 
print(s[1:])
print(s[:-2])

"""Series is also like a dictionary whose values can be set or fetched by index label:"""

# The program takes the values and sets it by index 
print(s[4])
s[4] = 0
print(s)

"""Series can also have a name attribute, which will be used when we make up a Pandas DataFrame using several series."""

# The program gives the series a name because the object series has this attribute
s = pd.Series(price, name = 'Apple Price List')
print(s)
print(s.name)

"""We can get the statistical summaries of a Series:"""

# The program gave us a description of the series that we are managing
print(s.describe())

"""## Time Index
Pandas has a built-in function specifically for creating date indices: pd.date_range(). We use it to create a new index for our Series:
"""

# The program gives to the function a date index, the difference is per days 
time_index = pd.date_range('2017-01-01',periods = len(s),freq = 'D')
print(time_index)
s.index = time_index
print(s)

"""Series are usually accessed using the iloc[] and loc[] methods. iloc[] is used to access elements by integer index, and loc[] is used to access the index of the series.

iloc[] is necessary when the index of a series are integers, take our previous defined series as example:
"""

# The program prints the object description and  takes an item of the series
s.index = [6,5,4,3,2,1]
print(s)
print(s[1])

"""If we intended to take the second element of the series, we would make a mistake here, because the index are integers. In order to access to the element we want, we use iloc[] here:"""

# The program takes the second iteme using the iloc function
print(s.iloc[1])

"""While working with time series data, we often use time as the index. Pandas provides us with various methods to access the data by time index"""

# The program access through the value using the index (the dates)
s.index = time_index
print(s['2017-01-03'])

"""We can even access to a range of dates:"""

# The program access to many values using many indexes 
print(s['2017-01-02':'2017-01-05'])

"""Series[] provides us a very flexible way to index data. We can add any condition in the square brackets:"""

print(s[s < np.mean(s)] ) # Prints the series using numPy and Pandas
print([(s > np.mean(s)) & (s < np.mean(s) + 1.64*np.std(s))]) #Compare the values of the series with the items of the matrix of np.

"""As demonstrated, we can use logical operators like & (and), | (or) and ~ (not) to group multiple conditions.

# Summary
Here we have introduced NumPy and Pandas for scientific computing in Python. In the next chapter, we will dive into Pandas to learn resampling and manipulating Pandas DataFrame, which are commonly used in financial data analysis.

<div align="center">
<img style="display: block; margin: auto;" alt="photo" src="https://cdn.quantconnect.com/web/i/icon.png"> <img style="display: block; margin: auto;" alt="photo" src="https://www.marketing-branding.com/wp-content/uploads/2020/07/google-colaboratory-colab-guia-completa.jpg " width="50" height="50">
<img style="display: block; margin: auto;" alt="photo" src="https://upload.wikimedia.org/wikipedia/commons/d/da/Yahoo_Finance_Logo_2019.svg" width="50" height="50">  

Quantconnect -> Google Colab with Yahoo Finance data

Introduction to Financial Python
</div>

# 05 Pandas-Resampling and DataFrame

# Introduction
In the last chapter we had a glimpse of Pandas. In this chapter we will learn about resampling methods and the DataFrame object, which is a powerful tool for financial data analysis.

# Fetching Data
Here we use the Yahoo Finance to retrieve data.
"""

# The program install retrieve data 
!pip install yfinance

import yfinance as yf

aapl = yf.Ticker("AAPL") 

# get stock info
print(aapl.info) # The program prints the aapl info 

# get historical market data
aapl_table = aapl.history(start="2016-01-01",  end="2017-12-31")
aapl_table
# In this part the program prints the history of the appl table, between 2016 and 2017

"""We will create a Series named "aapl" whose values are Apple's daily closing prices, which are of course indexed by dates:"""

aapl = aapl_table['Close']['2017']

# The program already created the condition to print the data above. The program will print the 2017 data
print(aapl)

"""Recall that we can fetch a specific data point using series['yyyy-mm-dd']. We can also fetch the data in a specific month using series['yyyy-mm']."""

# Now with the date condition the program can print a selected group of data
print(aapl['2017-3'])

# The program use a renge to print the data 
aapl['2017-2':'2017-4']

""".head(N) and .tail(N) are methods for quickly accessing the first or last N elements."""

print(aapl.head(5)) # With head function the program access to the first 5 datum
print(aapl.tail(10))# With the tail function the program access to the last 10 datum

"""# Resampling
**_series.resample(freq)_** is a class called "DatetimeIndexResampler" which groups data in a Series object into regular time intervals. The argument "freq" determines the length of each interval.

**_series.resample.mean()_** is a complete statement that groups data into intervals, and then compute the mean of each interval. For example, if we want to aggregate the daily data into monthly data by mean:
"""

# The program take de data of each month and makes a mean with the values that it has.
by_month = aapl.resample('M').mean() # As you can see the parameter is given by 'M'
print(by_month)

"""We can also aggregate the data by week:"""

# The program prints the values per week
by_week = aapl.resample('W').mean()
print(by_week.head())

"""We can also aggregate the data by month with max:"""

# The program takes the max value of each month 
aapl.resample('M').max()

"""We can choose almost any frequency by using the format 'nf', where 'n' is an integer and 'f' is M for month, W for week and D for day."""

# The program uses three types of frequency formats. The first has 3 days of separation between each other. The second has 2 weeks and the third has 2 months
three_day = aapl.resample('3D').mean()
two_week = aapl.resample('2W').mean()
two_month = aapl.resample('2M').mean()


print(three_day)
print(two_week)
print(two_month )

"""Besides the mean() method, other methods can also be used with the resampler:


"""

# The program is able to use other types of methods among which are max and min function
std = aapl.resample('W').std()
max = aapl.resample('W').max()
min = aapl.resample('W').min()


print(std)
print(max)
print(min)

"""Often we want to calculate monthly returns of a stock, based on prices on the last day of each month. To fetch those prices, we use the series.resample.agg() method:"""

# The program retrieves the returns of the prices of the last day of the month 
last_day = aapl.resample('M').agg(lambda x: x[-1])
print(last_day)

"""Or directly calculate the monthly rates of return using the data for the first day and the last day:"""

# The program calculates the monthly rates taking the first and last day 
monthly_return = aapl.resample('M').agg(lambda x: x[-1]/x[0] - 1)
print(monthly_return)

"""Series object also provides us some convenient methods to do some quick calculation."""

# The program makes a quick calculation of the mean, std, and max
print(monthly_return.mean())
print(monthly_return.std())
print(monthly_return.max())

"""Another two methods frequently used on Series are .diff() and .pct_change(). The former calculates the difference between consecutive elements, and the latter calculates the percentage change."""

print(last_day.diff()) # The function calculates the difference between consecutive elements
print(last_day.pct_change()) # The function calculates the porcentage of change

"""Notice that we induced a NaN value while calculating percentage changes i.e. returns.

When dealing with NaN values, we usually either removing the data point or fill it with a specific value. Here we fill it with 0:
"""

daily_return = last_day.pct_change()
print(daily_return.fillna(0)) # The program fills the data with 0's when it has a NAN values

"""Alternatively, we can fill a NaN with the next fitted value. This is called 'backward fill', or 'bfill' in short:"""

# Other option is using the 'bfill' function to fill with next fitted value the NAN data 
daily_return = last_day.pct_change()
print(daily_return.fillna(method = 'bfill'))

"""As expected, since there is a 'backward fill' method, there must be a 'forward fill' method, or 'ffill' in short. However we can't use it here because the NaN is the first value.

We can also simply remove NaN values by **_.dropna()_**
"""

# The program removes the NaN values using .dropna()
daily_return = last_day.pct_change()
daily_return.dropna()

"""# DataFrame
The **DataFrame** is the most commonly used data structure in Pandas. It is essentially a table, just like an Excel spreadsheet.

More precisely, a DataFrame is a collection of Series objects, each of which may contain different data types. A DataFrame can be created from various data types: dictionary, 2-D numpy.ndarray, a Series or another DataFrame.

## Create DataFrames
The most common method of creating a DataFrame is passing a dictionary:
"""

import pandas as pd #Import pandas 

# The program creates a dicionary using keys (as company names) and values (a list)
dict = {'AAPL': [143.5, 144.09, 142.73, 144.18, 143.77],'GOOG':[898.7, 911.71, 906.69, 918.59, 926.99],
        'IBM':[155.58, 153.67, 152.36, 152.94, 153.49]}

# The program gives a pandas index using dates
data_index = pd.date_range('2017-07-03',periods = 5, freq = 'D')

#The porgram creates the pandas frame
df = pd.DataFrame(dict, index = data_index)
print(df)

"""## Manipulating DataFrames
We can fetch values in a DataFrame by columns and index. Each column in a DataFrame is essentially a Pandas Series. We can fetch a column by square brackets: **df['column_name']**

If a column name contains no spaces, then we can also use df.column_name to fetch a column:
"""

df = aapl_table
print(df.Close.tail(5)) # The program print the last 5 itmes 
print(df['Volume'].tail(5)) # The program print the last 5 itmes giving it a condition or a special kind of the table

"""All the methods we applied to a Series index such as iloc[], loc[] and resampling methods, can also be applied to a DataFrame:"""

aapl_2016 = df['2016']
aapl_month = aapl_2016.resample('M').agg(lambda x: x[-1]) # The program resample the dataframe and prints it with all its columns 
print(aapl_month)

"""We may select certain columns of a DataFrame using their names:"""

#The program select certain columns to print 
aapl_bar = aapl_month[['Open', 'High', 'Low', 'Close']]
print(aapl_bar)

"""We can even specify both rows and columns using loc[]. The row indices and column names are separated by a comma:"""

# The program specify the rows and columns that has to be print 
print(aapl_month.loc['2016-03':'2016-06',['Open', 'High', 'Low', 'Close']])

"""The subset methods in DataFrame is quite useful. By writing logical statements in square brackets, we can make customized subsets:"""

import numpy as np # Import NumPy
# The program can creates a subset giving it a condition 
above = aapl_bar[aapl_bar.Close > np.mean(aapl_bar.Close)]
print(above)

"""## Data Validation
As mentioned, all methods that apply to a Series can also be applied to a DataFrame. Here we add a new column to an existing DataFrame:
"""

# The function adds a new column to the data frame
aapl_bar['rate_return'] = aapl_bar.Close.pct_change()
print(aapl_bar)

"""Here the calculation introduced a NaN value. If the DataFrame is large, we would not be able to observe it. **isnull()** provides a convenient way to check abnormal values."""

# .isnull() slices the dataframe to present us in a better way the abnormal data
missing = aapl_bar.isnull()
print(missing)
print('---------------------------------------------')
print(missing.describe())

"""The row labelled "unique" indicates the number of unique values in each column. Since the "rate_return" column has 2 unique values, it has at least one missing value.

We can deduce the number of missing values by comparing "count" with "freq". There are 12 counts and 11 False values, so there is one True value which corresponds to the missing value.

We can also find the rows with missing values easily:
"""

# The program let us know how many values are missing in the dataframe comparing the count and the freq of the dataframe
print(missing[missing.rate_return == True])

"""Usually when dealing with missing data, we either delete the whole row or fill it with some value. As we introduced in the Series chapter, the same method **dropna()** and **fillna()** can be applied to a DataFrame."""

# The program applied the fillna() and dropna() methods to a dataframe to fill or drop datums
drop = aapl_bar.dropna()
print(drop)
print('\n--------------------------------------------------\n')
fill = aapl_bar.fillna(0)
print(fill)

"""## DataFrame Concat
We have seen how to extract a Series from a dataFrame. Now we need to consider how to merge a Series or a DataFrame into another one.

In Pandas, the function **concat()** allows us to merge multiple Series into a DataFrame:
"""

# The program concats two series using the pandas concat() function
s1 = pd.Series([143.5, 144.09, 142.73, 144.18, 143.77], name = 'AAPL')
s2 = pd.Series([898.7, 911.71, 906.69, 918.59, 926.99], name = 'GOOG')
data_frame = pd.concat([s1,s2], axis = 1)
print(data_frame)

"""The "axis = 1" parameter will join two DataFrames by columns:"""

# The program concatenates two DataFrames by its columns 
log_price = np.log(aapl_bar.Close)
log_price.name = 'log_price'
print(log_price)
print('\n---------------------- separate line--------------------\n')
concat = pd.concat([aapl_bar, log_price], axis = 1) #The program concatenates the logprice with the dataFrame
print(concat)

"""We can also join two DataFrames by rows. Consider these two DataFrames:"""

# Also the function can join the DataFrames by its rows 
df_volume = aapl_table.loc['2016-10':'2017-04',['Volume', 'Stock Splits']].resample('M').agg(lambda x: x[-1])
print(df_volume) #First it takes one DataFrame
print('\n---------------------- separate line--------------------\n')
df_2017 = aapl_table.loc['2016-10':'2017-04',['Open', 'High', 'Low', 'Close']].resample('M').agg(lambda x: x[-1])#Then we reesample the other data Frame

"""Now we merge the DataFrames with our DataFrame 'aapl_bar'"""

# In this program the function concatenates per row both dataframes by its rows 
concat = pd.concat([aapl_bar, df_volume], axis = 1)
print(concat)

"""By default the DataFrame are joined with all of the data. This default options results in zero information loss. We can also merge them by intersection, this is called 'inner join"""

# The program concats by inner join, in other words, the prgram takes the vaules that are in both dataframes 
concat = pd.concat([aapl_bar,df_volume],axis = 1, join = 'inner')
print(concat)

"""Only the intersection part was left if use 'inner join' method. Now let's try to append a DataFrame to another one:"""

# The progam appends one DataFrame to another DataFrame 
append = aapl_bar.append(df_2017)
print(append)

"""'Append' is essentially to concat two DataFrames by axis = 0, thus here is an alternative way to append:"""

# The program present us other way to concatenate two DataFrames, for this case the program use a axis=0 as parameter
concat = pd.concat([aapl_bar, df_2017], axis = 0)
print(concat)

"""Please note that if the two DataFrame have some columns with the same column names, these columns are considered to be the same and will be merged. It's very important to have the right column names. If we change a column names here:"""

# The function change the names of some columns and then concatenates it. 
df_2017.columns = ['Change', 'High','Low','Close']
concat = pd.concat([aapl_bar, df_2017], axis = 0)
print(concat)

"""Since the column name of 'Open' has been changed, the new DataFrame has an new column named 'Change'.

# Summary

Hereby we introduced the most import part of python: resampling and DataFrame manipulation. We only introduced the most commonly used method in Financial data analysis. There are also many methods used in data mining, which are also beneficial. You can always check the [Pandas](https://pandas.pydata.org/pandas-docs/stable/index.html) official documentations for help.
"""